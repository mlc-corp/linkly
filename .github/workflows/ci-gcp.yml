name: CI gcp

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

# Evita carreras si hay múltiples pushes a la misma rama/PR
concurrency:
  group: ci-${{ github.workflow }}-${{ github.ref || github.run_id }}
  cancel-in-progress: true

jobs:
  # 1) Detectar qué carpetas cambiaron
  changed:
    name: Detectar cambios
    runs-on: ubuntu-latest
    outputs:
      frontend: ${{ steps.filter.outputs.frontend }}
      ms_admin: ${{ steps.filter.outputs.ms_admin }}
      ms_redirect: ${{ steps.filter.outputs.ms_redirect }}
      # Matriz JSON dinámica para el job de docker
      matrix: ${{ steps.matrix.outputs.matrix }}

    steps:
      - name: Checkout (full history for diff)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Necesario para que el paths-filter pueda comparar

      - name: Paths filter
        id: filter
        uses: dorny/paths-filter@v3
        with:
          # Para PRs, compara con la rama base.
          # Para pushes, compara con el commit anterior.
          base: ${{ github.event_name == 'push' && github.event.before || '' }}
          ref:  ${{ github.event_name == 'push' && github.sha || '' }}

          filters: |
            frontend:
              - 'frontend/**'
            ms_admin:
              - 'ms-admin/**'
            ms_redirect:
              - 'ms-redirect/**'

      - name: Install jq
        run: sudo apt-get install -y jq

      - name: set-matrix
        id: matrix
        run: |
          MATRIX_JSON="[]"
          if [ "${{ steps.filter.outputs.frontend }}" == "true" ]; then
            MATRIX_JSON=$(echo $MATRIX_JSON | jq '. + [{"id": "frontend", "context": "frontend", "dockerfile": "frontend/Dockerfile", "image_suffix": "linkly-frontend"}]')
          fi
          if [ "${{ steps.filter.outputs.ms_admin }}" == "true" ]; then
            MATRIX_JSON=$(echo $MATRIX_JSON | jq '. + [{"id": "ms-admin", "context": "ms-admin", "dockerfile": "ms-admin/Dockerfile", "image_suffix": "linkly-ms-admin"}]')
          fi
          if [ "${{ steps.filter.outputs.ms_redirect }}" == "true" ]; then
            MATRIX_JSON=$(echo $MATRIX_JSON | jq '. + [{"id": "ms-redirect", "context": "ms-redirect", "dockerfile": "ms-redirect/Dockerfile", "image_suffix": "linkly-ms-redirect"}]')
          fi
          
          FINAL_JSON=$(echo $MATRIX_JSON | jq -c .)
          echo "matrix=${FINAL_JSON}" >> $GITHUB_OUTPUT
          echo "Matriz generada: ${FINAL_JSON}"

  # 2) Build Docker (dinámico)
  docker-build-push:
    name: Docker · build(+push) · ${{ matrix.service.id }}
    # MODIFICADO: Depende solo de 'changed'
    needs: [changed]
    runs-on: ubuntu-latest
    
    # MODIFICADO: Condición de ejecución simplificada
    if: success() && needs.changed.outputs.matrix != '[]'

    # Matriz dinámica basada en la salida del job 'changed'
    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJson(needs.changed.outputs.matrix) }}

    steps:
      - uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        # Solo loguearse si vamos a hacer push (en main)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Compute image tags
        id: meta
        run: |
          REPO="${{ secrets.DOCKERHUB_USERNAME }}/${{ matrix.service.image_suffix }}"
          echo "repo=${REPO}" >> $GITHUB_OUTPUT
          # Usamos el SHA del commit como tag de versión
          echo "sha_tag=${REPO}:${GITHUB_SHA:0:8}" >> $GITHUB_OUTPUT
          echo "latest_tag=${REPO}:latest" >> $GITHUB_OUTPUT

      - name: Build (PR) / Build+Push (main)
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.context }}
          file: ${{ matrix.service.dockerfile }}
          # Push solo en merge a 'main'
          push: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
          tags: |
            ${{ steps.meta.outputs.sha_tag }}
            ${{ steps.meta.outputs.latest_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max